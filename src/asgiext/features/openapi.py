from __future__ import annotations

from copy import deepcopy
from typing import TYPE_CHECKING, Any, Callable, cast

import msgspec
import yaml
from apispec import APISpec, BasePlugin
from apispec.yaml_utils import load_operations_from_docstring  # type: ignore
from jinja2 import Environment
from yaml import parser, scanner

from asgiext.features.app_features.quart import QuartFeature
from asgiext.features.app_features.starlette import StarletteFeature
from asgiext.features.core import AbstractApplicationFeature, FeatureConfig

if TYPE_CHECKING:
    from collections.abc import Mapping


class OpenAPIConfig(FeatureConfig):
    """OpenAPIConfig."""

    enabled: bool = False
    generate_spec_on_startup: bool = True

    title: str = "asgiext"
    version: str = "1.0.0"

    openapi_version: str = "2.0"
    openapi_enabled: bool = True
    openapi_path: str = "/openapi.json"

    swagger_enabled: bool = False
    swagger_path: str = "/swagger"
    swagger_css_url: str = "https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.10.3/swagger-ui.min.css"
    swagger_js_url: str = "https://cdnjs.cloudflare.com/ajax/libs/swagger-ui/5.10.3/swagger-ui-bundle.js"

    rapidoc_enabled: bool = False
    rapidoc_path: str = "/rapidoc"
    rapidoc_js_url: str = "https://unpkg.com/rapidoc/dist/rapidoc-min.js"

    redoc_enabled: bool = False
    redoc_path: str = "/redoc"
    redoc_js_url: str = "https://cdn.redoc.ly/redoc/latest/bundles/redoc.standalone.js"

    stoplight_elements_enabled: bool = False
    stoplight_elements_path: str = "/elements"
    stoplight_elements_css_url: str = "https://unpkg.com/@stoplight/elements/styles.min.css"
    stoplight_elements_js_url: str = "https://unpkg.com/@stoplight/elements/web-components.min.js"


SWAGGER_TEMPLATE = """
<!doctype html>
<head>
  <link type="text/css" rel="stylesheet" href="{{ swagger_css_url }}">
  <title>{{ title }}</title>
</head>
<body>
  <div id="swagger-ui"></div>
  <script src="{{ swagger_js_url }}"></script>
  <script>
    const ui = SwaggerUIBundle({
      deepLinking: true,
      dom_id: "#swagger-ui",
      layout: "BaseLayout",
      presets: [
        SwaggerUIBundle.presets.apis,
        SwaggerUIBundle.SwaggerUIStandalonePreset
      ],
      showExtensions: true,
      showCommonExtensions: true,
      url: "{{ openapi_path }}"
    });
  </script>
</body>
"""

RAPIDOC_TEMPLATE = """
<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <script type="module" src="{{ rapidoc_js_url }}"></script>
  <title>{{ title }}</title>
</head>
<body>
  <rapi-doc
    spec-url="{{ openapi_path }}"
    theme = "dark"
  > </rapi-doc>
</body>
</html>
"""

REDOC_TEMPLATE = """
<!doctype html>
<html>
<head>
  <title>{{ title }}</title>
</head>
<body>
  <redoc spec-url="{{ openapi_path }}"></redoc>
  <script src="{{ redoc_js_url }}"> </script>
</body>
</html>
"""

STOPLIGHT_ELEMENTS = """
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>{{ title }}</title>
    <script src="{{ stoplight_elements_js_url }}"></script>
    <link rel="stylesheet" href="{{ stoplight_elements_css_url }}">
  </head>
  <body>

    <elements-api
      apiDescriptionUrl="{{ openapi_path }}"
      router="hash"
      layout="sidebar"
    />

  </body>
</html>
"""

ASGIEXT_SCHEMA_HIDDEN_ATTRIBUTE = "_asgiext_schema_hidden"


def hide(func: Callable[..., Any]) -> Callable[..., Any]:
    """Mark the func as hidden.

    This will prevent the route from being included in the
    autogenerated documentation.
    """
    setattr(func, ASGIEXT_SCHEMA_HIDDEN_ATTRIBUTE, True)
    return func


class OpenAPIFeature(AbstractApplicationFeature[OpenAPIConfig]):
    """OpenAPIFeature."""

    name = "OPENAPI"
    _spec_dict: dict[str, Any] | None

    def __init__(  # noqa: PLR0913
        self,
        name: str | None = None,
        *,
        config: OpenAPIConfig | None = None,
        examples: Mapping[str, Mapping[str, Any] | str] | None = None,
        headers: Mapping[str, Mapping[str, Any] | str] | None = None,
        parameters: Mapping[str, Mapping[str, Any] | str] | None = None,
        responses: Mapping[str, Mapping[str, Any] | str] | None = None,
        schemas: Mapping[str, Mapping[str, Any] | str] | None = None,
        security_schemes: Mapping[str, Mapping[str, Any] | str] | None = None,
    ) -> None:
        super().__init__(name, config=config)
        # raw components (may be str)
        self.__examples = examples or {}
        self.__headers = headers or {}
        self.__parameters = parameters or {}
        self.__responses = responses or {}
        self.__schemas = schemas or {}
        self.__security_schemes = security_schemes or {}

        # converted components (dicts)
        self._examples: dict[str, Any] = {}
        self._headers: dict[str, Any] = {}
        self._parameters: dict[str, Any] = {}
        self._responses: dict[str, Any] = {}
        self._schemas: dict[str, Any] = {}
        self._security_schemes: dict[str, Any] = {}

        # you can register (some existing in OpenAPI 3.x but not in 2.0)
        # components only after initialization of the feature
        # to determine the version from the config
        self.is_initialized = False

    ####################
    # FOR PUBLIC USAGE #
    ####################

    def get_spec_dict(self, *, regenerate: bool = False) -> dict[str, Any]:
        # You should never get an empty specification.
        # It can be empty if there was no generation on startup
        if regenerate or not self._spec_dict:
            self._spec_dict = self._generate_spec()
        return deepcopy(self._spec_dict)

    def register_example(self, example_id: str, example_data: dict[str, Any] | str, *, override: bool = False) -> None:
        if not self.is_initialized:
            msg = "OpenAPIFeature must be initialized to register examples to determine the version from the config"
            raise RuntimeError(msg)
        is_openapi_v2 = self.config.openapi_version.startswith("2")
        if is_openapi_v2:
            msg = "Examples not supported in OpenAPI 2.0"
            raise ValueError(msg)
        if example_id in self._examples and not override:
            msg = f"Example by that name {example_id!r} already exists"
            raise ValueError(msg)
        self._examples[example_id] = self._extract_component_data(example_data)

    def register_header(self, header_id: str, header_data: dict[str, Any] | str, *, override: bool = False) -> None:
        if not self.is_initialized:
            msg = "OpenAPIFeature must be initialized to register headers to determine the version from the config"
            raise RuntimeError(msg)
        is_openapi_v2 = self.config.openapi_version.startswith("2")
        if is_openapi_v2:
            msg = "Headers not supported in OpenAPI 2.0"
            raise ValueError(msg)
        if header_id in self._headers and not override:
            msg = f"Header by that name {header_id!r} already exists"
            raise ValueError(msg)
        self._headers[header_id] = self._extract_component_data(header_data)

    def register_parameter(
        self, parameter_id: str, parameter_data: dict[str, Any] | str, *, override: bool = False
    ) -> None:
        if parameter_id in self._parameters and not override:
            msg = f"Parameter by that name {parameter_id!r} already exists"
            raise ValueError(msg)
        self._parameters[parameter_id] = self._extract_component_data(parameter_data)

    def register_response(
        self, response_id: str, response_data: dict[str, Any] | str, *, override: bool = False
    ) -> None:
        if response_id in self._responses and not override:
            msg = f"Response by that name {response_id!r} already exists"
            raise ValueError(msg)
        self._responses[response_id] = self._extract_component_data(response_data)

    def register_schema(self, schema_id: str, schema_data: dict[str, Any] | str, *, override: bool = False) -> None:
        if schema_id in self._schemas and not override:
            msg = f"Schema by that name {schema_id!r} already exists"
            raise ValueError(msg)
        self._schemas[schema_id] = self._extract_component_data(schema_data)

    def register_security_scheme(
        self, security_scheme_id: str, security_scheme_data: dict[str, Any] | str, *, override: bool = False
    ) -> None:
        if security_scheme_id in self._security_schemes and not override:
            msg = f"Security scheme by that name {security_scheme_id!r} already exists"
            raise ValueError(msg)
        self._security_schemes[security_scheme_id] = self._extract_component_data(security_scheme_data)

    def render_swagger_html(self) -> str:
        return (
            Environment(autoescape=True)
            .from_string(SWAGGER_TEMPLATE)
            .render(
                title=self.config.title,
                openapi_path=self.config.openapi_path,
                swagger_css_url=self.config.swagger_css_url,
                swagger_js_url=self.config.swagger_js_url,
            )
        )

    def render_rapidoc_html(self) -> str:
        return (
            Environment(autoescape=True)
            .from_string(RAPIDOC_TEMPLATE)
            .render(
                title=self.config.title,
                openapi_path=self.config.openapi_path,
                rapidoc_js_url=self.config.rapidoc_js_url,
            )
        )

    def render_redoc_html(self) -> str:
        return (
            Environment(autoescape=True)
            .from_string(REDOC_TEMPLATE)
            .render(
                title=self.config.title,
                openapi_path=self.config.openapi_path,
                redoc_js_url=self.config.redoc_js_url,
            )
        )

    def render_stoplight_elements_html(self) -> str:
        return (
            Environment(autoescape=True)
            .from_string(STOPLIGHT_ELEMENTS)
            .render(
                title=self.config.title,
                openapi_path=self.config.openapi_path,
                stoplight_elements_css_url=self.config.stoplight_elements_css_url,
                stoplight_elements_js_url=self.config.stoplight_elements_js_url,
            )
        )

    ####################
    # NON-PUBLIC USAGE #
    ####################

    def init(self) -> None:
        """Init."""
        self.is_initialized = True

        is_openapi_v2 = self.config.openapi_version.startswith("2")

        if self.__examples and is_openapi_v2:
            msg = "Examples not supported in OpenAPI 2.0"
            raise ValueError(msg)
        for example_id, example_data in self.__examples.items():
            self._examples[example_id] = self._extract_component_data(example_data)

        if self.__headers and is_openapi_v2:
            msg = "Headers not supported in OpenAPI 2.0"
            raise ValueError(msg)
        for header_id, header_data in self.__headers.items():
            self._headers[header_id] = self._extract_component_data(header_data)

        for parameter_id, parameter_data in self.__parameters.items():
            self._parameters[parameter_id] = self._extract_component_data(parameter_data)

        for response_id, response_data in self.__responses.items():
            self._responses[response_id] = self._extract_component_data(response_data)

        for schema_id, schema_data in self.__schemas.items():
            self._schemas[schema_id] = self._extract_component_data(schema_data)

        for security_scheme_id, security_scheme_data in self.__security_schemes.items():
            self._security_schemes[security_scheme_id] = self._extract_component_data(security_scheme_data)

        self._setup_openapi_for_asgi_framework()

    def _setup_openapi_for_asgi_framework(self) -> None:
        app_feature = self.ft_store.app_feature
        if isinstance(app_feature, QuartFeature):
            self._setup_openapi_for_quart(app_feature)
        if isinstance(app_feature, StarletteFeature):
            self._setup_openapi_for_starlette(app_feature)
        else:
            msg = f"ASGI framework {type(app_feature.app)} not supported for {self!r}"
            raise TypeError(msg)

    def _setup_openapi_for_quart(self, app_feature: QuartFeature) -> None:
        from quart import Response

        app = app_feature.app

        hide(app.send_static_file.__func__)  # type: ignore
        if self.config.openapi_enabled:

            @hide
            async def openapi() -> Response:
                """Avoid key sorting (if enabled) on dict dump by standard JSONProvider class of Quart application.

                (more precisely sansio.app.App.json_provider_class).
                so that the all openapi.json keys are located in the order defined by the programmer in docstrings
                """
                return Response(msgspec.json.encode(self._spec_dict), content_type="application/json")

            app.get(self.config.openapi_path)(openapi)
        if self.config.swagger_enabled:

            @hide
            async def swagger_ui() -> str:
                return self.render_swagger_html()

            app.get(self.config.swagger_path)(swagger_ui)
        if self.config.rapidoc_enabled:

            @hide
            async def rapidoc_ui() -> str:
                return self.render_swagger_html()

            app.get(self.config.rapidoc_path)(rapidoc_ui)
        if self.config.redoc_enabled:

            @hide
            async def redoc_ui() -> str:
                return self.render_swagger_html()

            app.get(self.config.redoc_path)(redoc_ui)
        if self.config.stoplight_elements_enabled:

            @hide
            async def stoplight_elements_ui() -> str:
                return self.render_swagger_html()

            app.get(self.config.stoplight_elements_path)(stoplight_elements_ui)

    def _setup_openapi_for_starlette(self, app_feature: StarletteFeature) -> None:
        from starlette.requests import Request  # noqa: TCH002
        from starlette.responses import Response

        app = app_feature.app

        if self.config.openapi_enabled:

            @hide
            async def openapi(request: Request) -> Response:  # noqa: ARG001
                """Avoid key sorting"""
                return Response(msgspec.json.encode(self._spec_dict), media_type="application/json")

            app.add_route(self.config.openapi_path, openapi)
        if self.config.swagger_enabled:

            @hide
            async def swagger_ui(request: Request) -> Response:  # noqa: ARG001
                return Response(self.render_swagger_html())

            app.add_route(self.config.swagger_path, swagger_ui)
        if self.config.rapidoc_enabled:

            @hide
            async def rapidoc_ui(request: Request) -> Response:  # noqa: ARG001
                return Response(self.render_swagger_html())

            app.add_route(self.config.rapidoc_path, rapidoc_ui)
        if self.config.redoc_enabled:

            @hide
            async def redoc_ui(request: Request) -> Response:  # noqa: ARG001
                return Response(self.render_swagger_html())

            app.add_route(self.config.redoc_path, redoc_ui)
        if self.config.stoplight_elements_enabled:

            @hide
            async def stoplight_elements_ui(request: Request) -> Response:  # noqa: ARG001
                return Response(self.render_swagger_html())

            app.add_route(self.config.stoplight_elements_path, stoplight_elements_ui)

    def _generate_spec(self) -> dict[str, Any]:
        spec = APISpec(
            title=self.config.title,
            version=self.config.version,
            openapi_version=self.config.openapi_version,
            plugins=[DocPlugin()],
        )
        for example_id, example_data in self._examples.items():
            spec.components.example(example_id, example_data)  # type: ignore
        for header_id, header_data in self._headers.items():
            spec.components.header(header_id, header_data)  # type: ignore
        for parameter_id, parameter_data in self._parameters.items():
            spec.components.parameter(parameter_id, parameter_data)  # type: ignore
        for response_id, response_data in self._responses.items():
            spec.components.response(response_id, response_data)  # type: ignore
        for schema_id, schema_data in self._schemas.items():
            spec.components.schema(schema_id, schema_data)  # type: ignore
        for security_scheme_id, security_scheme_data in self._security_schemes.items():
            spec.components.security_scheme(security_scheme_id, security_scheme_data)  # type: ignore

        for path, route in self.ft_store.app_feature.get_http_routes():
            if getattr(route, ASGIEXT_SCHEMA_HIDDEN_ATTRIBUTE, False):
                continue
            spec.path(path=path, func=route)  # type: ignore

        return spec.to_dict()

    @staticmethod
    def _extract_component_data(component_data: Mapping[str, Any] | str) -> Mapping[str, Any]:
        if isinstance(component_data, str):
            try:
                return yaml.safe_load(component_data)
            except (scanner.ScannerError, parser.ParserError) as error:
                msg = "Unable to load yaml for openapi component from string"
                raise ValueError(msg) from error
        return component_data

    async def on_startup(self) -> None:
        """On startup."""
        if self.config.generate_spec_on_startup:
            self._spec_dict = self._generate_spec()

    async def on_shutdown(self) -> None:
        """On shutdown."""


class DocPlugin(BasePlugin):
    # from apispec docs, there is such IncompatibleethodOverride
    def operation_helper(self, operations: dict[str, Any], func: Callable[..., Any], **kwargs: Any) -> None:  # noqa: ARG002, ANN401  # type: ignore
        """Operation helper that parses docstrings for operations."""
        if func.__doc__:
            try:
                doc_operations = cast(dict[str, Any], load_operations_from_docstring(func.__doc__))
            except (scanner.ScannerError, parser.ParserError) as error:
                msg = f"Invalid docstring for {func.__name__!r}"
                raise ValueError(msg) from error
            if doc_operations:
                operations.update(doc_operations)
